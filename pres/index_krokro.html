<!DOCTYPE html>
<html>
<head>
    <title>Presentation template</title>
    <meta charset="utf-8"/>
    <link href="core/fonts/mono.css" rel="stylesheet" type="text/css">
    <link href="core/css/animate.css" rel="stylesheet" type="text/css">
    <link href="core/css/style_core.css" rel="stylesheet" type="text/css">
    <link href="core/css/mermaid.css" rel="stylesheet" type="text/css">
    <link href="core/css/gitgraph.css" rel="stylesheet" type="text/css">
    <link href="core/css/style_ensiie.css" rel="stylesheet" type="text/css">
    <link href="core/css/katex.css" rel="stylesheet" type="text/css">
    <link href="core/css/asciinema-player.css" rel="stylesheet" type="text/css">
</head>
<body>
<textarea id="source" readonly>
class: titlepage

.title[
Projet n°2 d'IPS
]

.subtitle[
V. Dubromer - M. Migdal - L. Scravaglieri -- ENSIIE -- 2020
]

---

layout: true
class: animated fadeIn middle numbers

.footnote[
Presentation template - N. Dubray - ENSIIE - 2020 - [:book:](../index.html)
]

---

class: toc top
# Table des matières

1. Présentation du projet
    1. Le problème
    2. Physique
    3. Structure 
--

2. Solution
    1. Implémentation naïve
    2. Tests unitaires
--

3. Optimisation et Benchmarks
    1. Code
    2. Quadrature
    3. Tests unitaires
--

4. Git

--

5. Résultats


---

# I.1 - Le problème 

.center[
On veut calculer une densité nucléaire locale dans le plan à l'aide de la formule suivante :
 
​

`$$\rho(\mathbf{r})\equiv \sum_a \sum_b \rho_{ab}\psi_a(\mathbf{r})\psi^*_b(\mathbf{r})$$`
]


---

# I.2 - Physique

Pour cela, nous avons eu besoin de calculer :
.center[
`$$\psi_{m,n,n_z}(r_\perp, \theta, z) = Z(z, n_z) . R(r_\perp, m, n) . e^{im\theta}$$`
]

Et donc, implémenter les fonctions suivantes, nécessitant respectivement le calcul de polynômes de Laguerre et de Hermite :

.center[
`$$Z(z, n_z) = \frac{1}{\sqrt{b_z}} \frac{1}{\sqrt{2^{n_z} \sqrt{\pi}n_z!}} e^{-\frac{z^2}{2b_z^2}}H_{n_z}\left(\frac{z}{b_z}\right)$$`
]

et

.center[
`$$R(r_\perp, m, n) = \frac{1}{b_{\perp}\sqrt{\pi}} \sqrt{\frac{n!}{(n+|m|)!}} e^{-\frac{r_{\perp}^2}{2b_{\perp}^2}} \left(\frac{r_{\perp}}{b_{\perp}}\right)^{|m|} L_n^{|m|}\left(\frac{r_{\perp}^2}{b_{\perp}^2}\right).$$`
]

---

class: toc top

# I.3 - Structure 

i. `Arborescence`

--

ii. `Classes`

--

iii. `Chaîne de compilation`

--

iv. `Documentation`


---

class: toc top

# i - Arborescence

1. `src`

--

2. `tests`

--

3. `scripts`

--

4. `doc`

--

5. `gtest`

--

```c
Makefile                                // Makefile principal servant à compiler le code et la documentation
README.md                               // 
├── scripts/                            // Scripts python permettant de récupérer les visuels (résultats)
    ├── csv_plotter.py
    ├── generateHermiteCoefs.py
├── src/                                // Sources
    ├── NuclearDensityCalculator.cpp
    ├── Basis.cpp
    ├── main.cpp
    ├── Saver.cpp
    └── Poly.cpp
├── tests/                              // Tests obligatoires et autres tests nous ayant semblé pertinents
    ├── testsMandatory.cpp
    ├── testNuclearDensityCalculator.cpp
```

---

# ii -  Classes

![](images/class-diagram.png)


---

class: top

# iii - Chaîne de compilation

Chaîne de compilation séparée en deux parties :
* Solveur
* GoogleTest

--

Approche modulaire 

--

Tous les modules doivent être déclarés au préalale dans les fichiers `module`.

--

```Makefile
CC = g++ -std=c++11 -fopenmp
LD = $(CC) -std=c++11 -larmadillo
CFLAGS = -Wall -Wextra -O2 -I /usr/local/include -march=native -mtune=native
TEST_CFLAGS += $(CFLAGS) -I$(FUSED_GTEST_TMP_DIR) -larmadillo -Og -DGTEST_HAS_PTHREAD=0
LDFLAGS = -Wall -Wextra -larmadillo
``` 

--

```Makefile
BINDIR = bin
OBJDIR = obj
SRCDIR = src
DOCDIR = doc
TEST_SRCDIR = tests
FUSED_GTEST_TMP_DIR = tmp
GTEST_SRC = gtest

TARGET = $(BINDIR)/nuclearDensity
TEST_TARGET = $(BINDIR)/tests

all : makedirs $(TARGET)
``` 

---

# iii - Chaîne de compilation

```Makefile
CC = g++ -std=c++11 -fopenmp
LD = $(CC) -std=c++11 -larmadillo
CFLAGS = -Wall -Wextra -O2 -I /usr/local/include -march=native -mtune=native
TEST_CFLAGS += $(CFLAGS) -I$(FUSED_GTEST_TMP_DIR) -larmadillo -Og -DGTEST_HAS_PTHREAD=0
LDFLAGS = -Wall -Wextra -larmadillo
``` 

```Makefile
BINDIR = bin
OBJDIR = obj
SRCDIR = src
DOCDIR = doc
TEST_SRCDIR = tests
FUSED_GTEST_TMP_DIR = tmp
GTEST_SRC = gtest

TARGET = $(BINDIR)/nuclearDensity
TEST_TARGET = $(BINDIR)/tests

all : makedirs $(TARGET)
``` 

```Makefile
MAIN_SRC = $(addprefix $(SRCDIR)/, $(MAIN:=.cpp))
MAIN_OBJ = $(addprefix $(OBJDIR)/, $(MAIN:=.o))
SOURCES = $(addprefix $(SRCDIR)/, $(MODULES:=.cpp))
OBJECTS = $(addprefix $(OBJDIR)/, $(MODULES:=.o))
ALL_OBJECTS = $(OBJECTS) $(MAIN_OBJ)
ALL_HEADERS = $(addprefix $(SRCDIR)/, $(ORPHANED_HEADERS:=.h))
ALL_SOURCES = $(SOURCES) $(MAIN_SRC)

$(TARGET) : $(ALL_OBJECTS) $(ALL_SOURCES) $(ALL_HEADERS)
	$(LD) $(LDFLAGS) -o $@ $(ALL_OBJECTS)

$(MAIN_OBJ): obj/%.o : src/%.cpp $(MAIN_SRC)
	$(CC) $(CFLAGS) -c -o $@ $<

$(OBJECTS): obj/%.o : src/%.cpp $(SOURCES) $(ALL_HEADERS)
	$(CC) $(CFLAGS) -c -o $@ $<
```

---

# iv - Documentation

--
* Doxygen

--
* EXTRACT_PRIVATE = YES

--
* INPUT += README.md
* USE_MDFILE_AS_MAINPAGE = README.md

--
* EXCLUDE = src/hermiteCoefs.h

---

# iv - Documentation

![](images/index.png)

---

# iv - Documentation

![](images/orthocheck.png)

---

# II.1 - Implémentation naïve

.center[
`$$\rho(\mathbf{r}) = \sum_{m}\sum_{n}\sum_{n_z}\sum_{mp}\sum_{np}\sum_{n_{zp}}(\rho_{m, n, n_z, mp,np,n_{zp}}\psi_{m,n,n_z}(\mathbf{r})\psi^*_{mp,np,n_{zp}}(\mathbf{r}))$$`
]

```c++
arma::mat NuclearDensityCalculator::naive_method(const arma::vec& rVals, const arma::vec& zVals)
{
    Chrono local("naive_method");
    arma::mat result = arma::zeros(rVals.size(), zVals.size()); // number of points on r- and z- axes
    for (int m = 0; m<basis.mMax; m++) {
        for (int n = 0; n<basis.nMax(m); n++) {
            for (int n_z = 0; n_z<basis.n_zMax(m, n); n_z++) {
                for (int mp = 0; mp<basis.mMax; mp++) {
                    for (int np = 0; np<basis.nMax(mp); np++) {
                        for (int n_zp = 0; n_zp<basis.n_zMax(mp, np); n_zp++) {
                            arma::mat funcA = basis.basisFunc(m, n, n_z, rVals, zVals);
                            arma::mat funcB = basis.basisFunc(mp, np, n_zp, rVals, zVals);
                            result += funcA%funcB*rho(m, n, n_z, mp, np, n_zp);
                        }
                    }
                }
            }
        }
    }
    return result;
}
```

---

#II.2 - Tests unitaires

TODO : Ajout des tests unitaires pour l'implémentation naïve

---

# III.1 - Code

```markdown
void Derivator::differentiateTwice(arma::mat &m) {
        arma::uword n = m.n_cols;
        arma::mat M1 = m;
        arma::mat M2 = m;

        if (likely(n > 2)) {

            M1.shed_col(0);
            M1.insert_cols(n - 1, 1);
            
            M2.shed_col(n - 1);
            M2.insert_cols(0, 1);
        
            m = (M1 + M2 - 2 * m) / (STEP * STEP);
        }

        else {

            m = arma::zeros(size(m));
        }
}
```



`$$ (x_1, x_2, ... , x_n)  \longrightarrow (\frac{0 + x_2 - 2  x_1}{h^2}, \frac{x_1 + x_3 - 2  x_2}{h^2}, ... , \frac{x_{n-1} + 0 -2  x_n}{h^2})   $$`
---

# III.1 - Code

```markdown
void Derivator::correctBounds(arma::mat &m) {
    arma::uword n = m.n_cols;

    if (likely(n > 2)) {

        m.shed_col(n - 1);
        m.shed_col(0);
    }
}
```

`$$  (\frac{0 + x_2 - 2  x_1}{h^2}, \frac{x_1 + x_3 - 2  x_2}{h^2},\frac{x_2 + x_4 - 2  x_3}{h^2}, ... ,\frac{x_{n-2} + x_n -2  x_{n-1}}{h^2}, \frac{x_{n-1} + 0 -2  x_n}{h^2}) \\[0.4cm] \downarrow \\[0.4cm]  
(\frac{x_1 + x_3 - 2  x_2}{h^2}, \frac{x_2 + x_4 - 2  x_3}{h^2}, ... , \frac{x_{n-2} + x_n -2  x_{n-1}}{h^2})  $$`
---

class: top

# III.2 - Quadrature

On veut vérifier que `$ I_{a, b} = \delta_{a, b} $` avec :
`$$ I_{a, b} = \int \psi_a \psi_b \text{e}^{-\alpha z^2} = k_a k_b \int_{z_\text{min}}^{z_\text{max}}  H_a(z)H_b(z) \text{e}^{-\alpha z^2} \text{d}z $$`
où on a noté `$\alpha = \frac{m \omega}{h}$` et `$k_a = \frac{1}{\sqrt{2^a a!}}{\left(\frac{\alpha}{\pi} \right)}^{\frac{1}{4}} $`.
--
Après un changement de variable (formaliste mais inutile si on prend tous les paramètres égaux à 1 de toutes façons...), on a :
`$$ I_{a, b} = k_a k_b \int_{\sqrt{\alpha}z_\text{min}}^{\sqrt{\alpha}z_\text{max}}  H_a(z)H_b(z) \text{e}^{-z^2} \frac{\text{d}z}{\alpha} = k_a k_b \sum_{i = 0}^{N-1} \omega_i  H_a\left(\frac{x_i}{\sqrt{\alpha}} \right)H_b\left(\frac{x_i}{\sqrt{\alpha}} \right)    $$`
--

* `$k_n$` = `pseudoFactorials.at(n)`
* `$Vect \left( H_n\left(\frac{x_i}{\sqrt{\alpha}} \right), \forall i \in [0, N-1]   \right)$`   = `hermiteMatrix.row(n)`
* `$Vect \left( \omega_i , \forall i \in [0, N-1]  \right)$` = `getWeightVector()`

--

Pour la quadrature : `make coefs`


---

class: top

# III.2 - Quadrature - Profilage du code

Valeurs pré-calculables indépendantes de `$I_{a, b} $` -> classe instanciée:

--

Maximum de constantes dans `constants.h` et `hermiteCoefs.h` > "constant folding"

--

![](images/prof100.png)


![](images/prof1000.png)


---
# III.3 - Tests unitaires

GoogleTest

--

Tests paramétrés

--

.numbers[
```c++
/**
 * @struct define the parameter of SolutionBoundedTest
 */
struct solution_bounded_state {
    double zmin;
    double zmax;
    uint n;
    // expected number of rows in the resulting matrix
    uint length;

    /**
     * @brief format when printing a solution_bounded_state object
     */
    friend std::ostream &operator<<(std::ostream &os, const solution_bounded_state &state)
    {
      os << "zmin=" << state.zmin << "; zmax=" << state.zmax;
      os << "; n=" << state.n << "; length=" << state.length << "}\n";
      return os;
    }
};
```
]

---

# III.3 - Tests unitaires

.numbers[
```cpp
/**
 * @class SolutionBoundedTest
 * This class defines parameterized tests using instances of solution_bounded_state as parameter
 */
class SolutionBoundedTest : public testing::TestWithParam<solution_bounded_state> {
 public:
  SolutionBoundedTest()
  = default;;
};

/**
 * @brief Creates an instance of SolutionBoundedTest that will run the given test
 */
TEST_P(SolutionBoundedTest, solutionSize)
{
  solution_bounded_state state = GetParam();
  arma::mat result = SolverSchrodinger::solve1D(state.zmin, state.zmax, state.n);

  EXPECT_EQ(state.n + 1, result.n_rows);
  EXPECT_EQ(state.length, result.n_cols);
}

/**
 * Run all SolutionBoundedTest tests with given values
 */
INSTANTIATE_TEST_SUITE_P(BasicCases, SolutionBoundedTest, testing::Values(
    solution_bounded_state{-1, 1, 1, uint((2 / STEP) + 1)},
    solution_bounded_state{-10, 10, 1, uint((20 / STEP) + 1)},
    solution_bounded_state{-1, 1, 4, uint((2 / STEP) + 1)}
));
```
]

---

# IV - Git
 Git History (tig)

 .hcenter.w83[
![](../pres/images/git_history.png)
]


---

class: center

# V - Résultats

.w80.hcenter[
![](images/Figure_1.png)
]


---

class: center

# V - Résultats

.w60.hcenter[
![](images/gcov.png)
]






</textarea>

<script src="core/javascript/remark.js"></script>
<script src="core/javascript/katex.min.js"></script>
<script src="core/javascript/auto-render.min.js"></script>
<script src="core/javascript/emojify.js"></script>
<script src="core/javascript/mermaid.js"></script>
<script src="core/javascript/jquery-2.1.1.min.js"></script>
<script src="core/javascript/extend-jquery.js"></script>
<script src="core/javascript/gitgraph.js"></script>
<script src="core/javascript/plotly.js"></script>
<script src="core/javascript/asciinema-player.js"></script>
<script src="core/javascript/bokeh-2.2.1.min.js"></script>
<script src="core/javascript/bokeh-widgets-2.2.1.min.js"></script>
<script src="core/javascript/bokeh-tables-2.2.1.min.js"></script>
<script src="core/javascript/bokeh-api-2.2.1.min.js"></script>

<script>

    // === Remark.js initialization ===
    var slideshow = remark.create(
        {
            highlightStyle: 'monokai',
            countIncrementalSlides: false,
            highlightLines: false
        });

    // === Mermaid.js initialization ===
    mermaid.initialize({
        startOnLoad: false,
        cloneCssStyles: false,
        flowchart: {
            height: 50
        },
        sequenceDiagram: {
            width: 110,
            height: 30
        }
    });

    function initMermaid(s) {
        var diagrams = document.querySelectorAll('.mermaid');
        var i;
        for (i = 0; i < diagrams.length; i++) {
            if (diagrams[i].offsetWidth > 0) {
                mermaid.init(undefined, diagrams[i]);
            }
        }
    }

    slideshow.on('afterShowSlide', initMermaid);
    initMermaid(slideshow.getSlides()[slideshow.getCurrentSlideIndex()]);


    // === Emojify.js initialization ===
    emojify.run();

    // KaTeX
    renderMathInElement(document.body, {
        delimiters: [{left: "$$", right: "$$", display: true}, {left: "$", right: "$", display: false}],
        ignoredTags: ["script", "noscript", "style", "textarea", "pre"]
    });


    // Bokeh.js example #00

    var plt = Bokeh.Plotting;

    var pie_data = {
        labels: ['Work', 'Eat', 'Commute', 'Sport', 'Watch TV', 'Sleep'],
        values: [8, 2, 2, 4, 0, 8],
    };

    var p1 = Bokeh.Charts.pie(pie_data);
    var p2 = Bokeh.Charts.pie(pie_data, {
        inner_radius: 0.2,
        start_angle: Math.PI / 2
    });
    var p3 = Bokeh.Charts.pie(pie_data, {
        inner_radius: 0.2,
        start_angle: Math.PI / 6,
        end_angle: 5 * Math.PI / 6
    });
    var p4 = Bokeh.Charts.pie(pie_data, {
        inner_radius: 0.2,
        palette: "Oranges9",
        slice_labels: "percentages"
    });

    // add the plot to a document and display it
    var doc = new Bokeh.Document();
    doc.add_root(plt.gridplot(
        [[p1, p2], [p3, p4]],
        {plot_width: 250, plot_height: 250}));
    Bokeh.embed.add_document_standalone(doc, document.getElementById("bokeh00"));

    // Bokeh.js example #01

    var plt = Bokeh.Plotting;

    var bar_data = [
        ['City', '2010 Population', '2000 Population'],
        ['NYC', 8175000, 8008000],
        ['LA', 3792000, 3694000],
        ['Chicago', 2695000, 2896000],
        ['Houston', 2099000, 1953000],
        ['Philadelphia', 1526000, 1517000],
    ];

    var p1 = Bokeh.Charts.bar(bar_data, {
        axis_number_format: "0.[00]a"
    });
    var p2 = Bokeh.Charts.bar(bar_data, {
        axis_number_format: "0.[00]a",
        stacked: true
    });
    var p3 = Bokeh.Charts.bar(bar_data, {
        axis_number_format: "0.[00]a",
        orientation: "vertical"
    });
    var p4 = Bokeh.Charts.bar(bar_data, {
        axis_number_format: "0.[00]a",
        orientation: "vertical",
        stacked: true
    });

    var doc = new Bokeh.Document();
    doc.add_root(plt.gridplot(
        [[p1, p2], [p3, p4]],
        {plot_width: 250, plot_height: 250}));
    Bokeh.embed.add_document_standalone(doc, document.getElementById("bokeh01"));

    // ===== END =====

</script>
<script src="gitgraphs.js" type="text/javascript"></script>
</body>
</html>

